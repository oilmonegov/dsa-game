import type { MatchChallenge } from '@/types/realworld';
import { DATA_STRUCTURES } from '@/types/realworld';

export const realWorldChallenges: MatchChallenge[] = [
  // Easy challenges - 3-4 matches
  {
    id: 1,
    title: 'Everyday Data Structures',
    description: 'Match common data structures to their everyday applications.',
    difficulty: 'easy',
    category: 'Fundamentals',
    structures: [DATA_STRUCTURES.stack, DATA_STRUCTURES.queue, DATA_STRUCTURES.array],
    applications: [
      {
        id: 'undo',
        title: 'Undo/Redo in Text Editors',
        description: 'Reverses your last actions in order',
        icon: '‚Ü©Ô∏è',
        matchesStructure: 'stack',
      },
      {
        id: 'printer',
        title: 'Print Job Queue',
        description: 'Documents print in the order they were sent',
        icon: 'üñ®Ô∏è',
        matchesStructure: 'queue',
      },
      {
        id: 'playlist',
        title: 'Music Playlist',
        description: 'Sequential list of songs with direct access by position',
        icon: 'üéµ',
        matchesStructure: 'array',
      },
    ],
    explanations: {
      stack: 'Stacks use LIFO - the last action you did is the first one undone!',
      queue: 'Queues use FIFO - first document sent is the first one printed!',
      array: 'Arrays provide O(1) access to any position - perfect for playlists!',
    },
    hint: 'Think about the order in which items are processed.',
  },
  {
    id: 2,
    title: 'Web Browser Features',
    description: 'How does your browser use data structures?',
    difficulty: 'easy',
    category: 'Web Development',
    structures: [DATA_STRUCTURES.stack, DATA_STRUCTURES.hashTable, DATA_STRUCTURES.queue],
    applications: [
      {
        id: 'history',
        title: 'Browser Back Button',
        description: 'Navigate to previously visited pages',
        icon: '‚¨ÖÔ∏è',
        matchesStructure: 'stack',
      },
      {
        id: 'cache',
        title: 'Browser Cache',
        description: 'Quick lookup of recently visited page data',
        icon: 'üíæ',
        matchesStructure: 'hashTable',
      },
      {
        id: 'downloads',
        title: 'Download Queue',
        description: 'Files download in the order requested',
        icon: '‚¨áÔ∏è',
        matchesStructure: 'queue',
      },
    ],
    explanations: {
      stack: 'Browser history is a stack - back button pops the most recent page!',
      hashTable: 'Cache uses URL as key for O(1) lookup of stored page data!',
      queue: 'Downloads process in FIFO order - first requested, first downloaded!',
    },
    hint: 'Consider how you navigate backwards and how fast lookups work.',
  },
  {
    id: 3,
    title: 'Operating System Basics',
    description: 'Data structures powering your OS.',
    difficulty: 'easy',
    category: 'Systems',
    structures: [DATA_STRUCTURES.queue, DATA_STRUCTURES.stack, DATA_STRUCTURES.linkedList],
    applications: [
      {
        id: 'cpu',
        title: 'CPU Task Scheduling',
        description: 'Processes waiting for CPU time',
        icon: 'üñ•Ô∏è',
        matchesStructure: 'queue',
      },
      {
        id: 'callstack',
        title: 'Function Call Stack',
        description: 'Tracks nested function calls and returns',
        icon: 'üìû',
        matchesStructure: 'stack',
      },
      {
        id: 'memory',
        title: 'Memory Allocation Blocks',
        description: 'Free memory blocks of varying sizes',
        icon: 'üßÆ',
        matchesStructure: 'linkedList',
      },
    ],
    explanations: {
      queue: 'CPU scheduling often uses queues - processes run in arrival order (round-robin)!',
      stack: 'Function calls push onto the stack, returns pop off - hence "stack overflow"!',
      linkedList: 'Free memory blocks form a linked list - easy to insert/remove any block!',
    },
    hint: 'Think about order of processing and dynamic memory management.',
  },

  // Medium challenges - 4-5 matches
  {
    id: 4,
    title: 'Social Media Architecture',
    description: 'How social networks organize data.',
    difficulty: 'medium',
    category: 'Social Media',
    structures: [
      DATA_STRUCTURES.graph,
      DATA_STRUCTURES.hashTable,
      DATA_STRUCTURES.queue,
      DATA_STRUCTURES.heap,
    ],
    applications: [
      {
        id: 'friends',
        title: 'Friend Connections',
        description: 'Network of who is connected to whom',
        icon: 'üë•',
        matchesStructure: 'graph',
      },
      {
        id: 'profile',
        title: 'User Profile Lookup',
        description: 'Finding user data by username',
        icon: 'üë§',
        matchesStructure: 'hashTable',
      },
      {
        id: 'notifications',
        title: 'Notification Queue',
        description: 'Processing notifications in order received',
        icon: 'üîî',
        matchesStructure: 'queue',
      },
      {
        id: 'trending',
        title: 'Trending Topics',
        description: 'Keeping track of most popular items',
        icon: 'üìà',
        matchesStructure: 'heap',
      },
    ],
    explanations: {
      graph: 'Social networks are graphs - users are nodes, friendships are edges!',
      hashTable: 'Hash tables enable O(1) lookup by username or user ID!',
      queue: 'Notifications process in FIFO order to maintain chronology!',
      heap: 'Heaps efficiently track top-K items - perfect for trending content!',
    },
    hint: 'Consider relationships, fast lookups, ordering, and priority.',
  },
  {
    id: 5,
    title: 'E-Commerce Systems',
    description: 'Data structures behind online shopping.',
    difficulty: 'medium',
    category: 'E-Commerce',
    structures: [
      DATA_STRUCTURES.hashTable,
      DATA_STRUCTURES.bst,
      DATA_STRUCTURES.queue,
      DATA_STRUCTURES.array,
    ],
    applications: [
      {
        id: 'cart',
        title: 'Shopping Cart',
        description: 'Quick lookup of items by product ID',
        icon: 'üõí',
        matchesStructure: 'hashTable',
      },
      {
        id: 'priceRange',
        title: 'Price Range Filter',
        description: 'Finding products within a price range',
        icon: 'üí∞',
        matchesStructure: 'bst',
      },
      {
        id: 'orders',
        title: 'Order Processing',
        description: 'Orders processed in sequence received',
        icon: 'üì¶',
        matchesStructure: 'queue',
      },
      {
        id: 'recommendations',
        title: 'Product Recommendations',
        description: 'List of suggested products in ranked order',
        icon: '‚≠ê',
        matchesStructure: 'array',
      },
    ],
    explanations: {
      hashTable: 'Shopping carts use hash tables for O(1) product lookup and updates!',
      bst: 'BSTs enable efficient range queries - find all products $10-$50!',
      queue: 'Order fulfillment uses queues - first order in, first order shipped!',
      array: 'Recommendation lists use arrays - ranked by relevance score!',
    },
    hint: 'Think about lookups, ranges, ordering, and ranked lists.',
  },
  {
    id: 6,
    title: 'Search & Autocomplete',
    description: 'Data structures for text search features.',
    difficulty: 'medium',
    category: 'Search',
    structures: [
      DATA_STRUCTURES.trie,
      DATA_STRUCTURES.hashTable,
      DATA_STRUCTURES.heap,
      DATA_STRUCTURES.graph,
    ],
    applications: [
      {
        id: 'autocomplete',
        title: 'Search Autocomplete',
        description: 'Suggesting words as you type',
        icon: 'üîç',
        matchesStructure: 'trie',
      },
      {
        id: 'spellcheck',
        title: 'Spell Check Dictionary',
        description: 'Checking if a word exists',
        icon: 'üìù',
        matchesStructure: 'hashTable',
      },
      {
        id: 'topResults',
        title: 'Top Search Results',
        description: 'Showing best matches first',
        icon: 'üèÜ',
        matchesStructure: 'heap',
      },
      {
        id: 'related',
        title: 'Related Searches',
        description: 'Finding connected search terms',
        icon: 'üîó',
        matchesStructure: 'graph',
      },
    ],
    explanations: {
      trie: 'Tries store words by prefix - perfect for "starts with" autocomplete!',
      hashTable: 'Spell check needs O(1) word existence check - hash sets are ideal!',
      heap: 'Heaps maintain top-K results efficiently as scores update!',
      graph: 'Related searches form a graph - terms that appear together are connected!',
    },
    hint: 'Consider prefix matching, existence checks, and relationships.',
  },
  {
    id: 7,
    title: 'Gaming Applications',
    description: 'How video games use data structures.',
    difficulty: 'medium',
    category: 'Gaming',
    structures: [
      DATA_STRUCTURES.graph,
      DATA_STRUCTURES.priorityQueue,
      DATA_STRUCTURES.stack,
      DATA_STRUCTURES.hashTable,
    ],
    applications: [
      {
        id: 'pathfinding',
        title: 'NPC Pathfinding',
        description: 'Finding routes between locations on a map',
        icon: 'üó∫Ô∏è',
        matchesStructure: 'graph',
      },
      {
        id: 'events',
        title: 'Game Event Scheduling',
        description: 'Processing events by priority/time',
        icon: '‚è∞',
        matchesStructure: 'priorityQueue',
      },
      {
        id: 'states',
        title: 'Game State History',
        description: 'Saving and restoring game states',
        icon: 'üíæ',
        matchesStructure: 'stack',
      },
      {
        id: 'inventory',
        title: 'Player Inventory',
        description: 'Quick lookup of items by ID',
        icon: 'üéí',
        matchesStructure: 'hashTable',
      },
    ],
    explanations: {
      graph: 'Game maps are graphs - pathfinding algorithms like A* traverse them!',
      priorityQueue: 'Game events are scheduled by time using priority queues!',
      stack: 'Game states stack for undo/save-load functionality!',
      hashTable: 'Inventories use hash tables for O(1) item access!',
    },
    hint: 'Think about maps, timing, history, and fast lookups.',
  },

  // Hard challenges - 5-6 matches
  {
    id: 8,
    title: 'Database Internals',
    description: 'How databases organize and access data.',
    difficulty: 'hard',
    category: 'Databases',
    structures: [
      DATA_STRUCTURES.balancedTree,
      DATA_STRUCTURES.hashTable,
      DATA_STRUCTURES.heap,
      DATA_STRUCTURES.linkedList,
      DATA_STRUCTURES.array,
    ],
    applications: [
      {
        id: 'index',
        title: 'B-Tree Index',
        description: 'Efficient range queries on sorted data',
        icon: 'üìá',
        matchesStructure: 'balancedTree',
      },
      {
        id: 'hashIndex',
        title: 'Hash Index',
        description: 'Exact match lookups by key',
        icon: '#Ô∏è‚É£',
        matchesStructure: 'hashTable',
      },
      {
        id: 'topN',
        title: 'Top-N Query Results',
        description: 'Finding largest/smallest N values',
        icon: 'üîù',
        matchesStructure: 'heap',
      },
      {
        id: 'transactions',
        title: 'Transaction Log',
        description: 'Append-only record of changes',
        icon: 'üìú',
        matchesStructure: 'linkedList',
      },
      {
        id: 'buffer',
        title: 'Buffer Pool Pages',
        description: 'Fixed-size cache of disk pages',
        icon: 'üìÑ',
        matchesStructure: 'array',
      },
    ],
    explanations: {
      balancedTree: 'B-trees keep data sorted for efficient range scans and stay balanced!',
      hashTable: 'Hash indexes provide O(1) lookups for equality predicates!',
      heap: 'Heaps efficiently find top-N without sorting entire result set!',
      linkedList: 'Transaction logs append entries and traverse sequentially!',
      array: 'Buffer pools use fixed arrays of page-sized slots!',
    },
    hint: 'Consider sorted vs unsorted access, append operations, and fixed sizes.',
  },
  {
    id: 9,
    title: 'Network & Routing',
    description: 'Data structures in networking.',
    difficulty: 'hard',
    category: 'Networking',
    structures: [
      DATA_STRUCTURES.graph,
      DATA_STRUCTURES.trie,
      DATA_STRUCTURES.queue,
      DATA_STRUCTURES.hashTable,
      DATA_STRUCTURES.heap,
    ],
    applications: [
      {
        id: 'routing',
        title: 'Network Routing Tables',
        description: 'Finding shortest paths between nodes',
        icon: 'üõ§Ô∏è',
        matchesStructure: 'graph',
      },
      {
        id: 'ipLookup',
        title: 'IP Address Lookup',
        description: 'Matching IP prefixes to routes',
        icon: 'üåê',
        matchesStructure: 'trie',
      },
      {
        id: 'packets',
        title: 'Packet Buffer',
        description: 'Storing packets awaiting transmission',
        icon: 'üì®',
        matchesStructure: 'queue',
      },
      {
        id: 'connections',
        title: 'Active Connections Table',
        description: 'Tracking open TCP connections',
        icon: 'üîå',
        matchesStructure: 'hashTable',
      },
      {
        id: 'bandwidth',
        title: 'Bandwidth Allocation',
        description: 'Prioritizing network traffic',
        icon: 'üì∂',
        matchesStructure: 'heap',
      },
    ],
    explanations: {
      graph: 'Networks are graphs - Dijkstra/Bellman-Ford find shortest paths!',
      trie: 'IP routing uses tries for longest prefix matching!',
      queue: 'Packet buffers are queues - FIFO transmission order!',
      hashTable: 'Connection tables hash on (IP, port) tuples for O(1) lookup!',
      heap: 'QoS uses heaps to process high-priority traffic first!',
    },
    hint: 'Think about paths, prefixes, buffering, lookups, and priorities.',
  },
  {
    id: 10,
    title: 'Compiler Design',
    description: 'Data structures used in compilers.',
    difficulty: 'hard',
    category: 'Compilers',
    structures: [
      DATA_STRUCTURES.stack,
      DATA_STRUCTURES.hashTable,
      DATA_STRUCTURES.binaryTree,
      DATA_STRUCTURES.graph,
      DATA_STRUCTURES.queue,
    ],
    applications: [
      {
        id: 'parsing',
        title: 'Expression Parsing',
        description: 'Evaluating nested expressions with operators',
        icon: 'üßÆ',
        matchesStructure: 'stack',
      },
      {
        id: 'symbols',
        title: 'Symbol Table',
        description: 'Storing variable and function names',
        icon: 'üìã',
        matchesStructure: 'hashTable',
      },
      {
        id: 'ast',
        title: 'Abstract Syntax Tree',
        description: 'Representing program structure',
        icon: 'üå≥',
        matchesStructure: 'binaryTree',
      },
      {
        id: 'cfg',
        title: 'Control Flow Graph',
        description: 'Representing program execution paths',
        icon: 'üîÄ',
        matchesStructure: 'graph',
      },
      {
        id: 'optimization',
        title: 'Optimization Work Queue',
        description: 'Processing code blocks to optimize',
        icon: '‚ö°',
        matchesStructure: 'queue',
      },
    ],
    explanations: {
      stack: 'Expression parsing uses stacks for operator precedence (shunting-yard)!',
      hashTable: 'Symbol tables use hash tables for O(1) identifier lookup!',
      binaryTree: 'ASTs represent code hierarchically - operators are parents of operands!',
      graph: 'CFGs model all possible execution paths through the program!',
      queue: 'Worklist algorithms process basic blocks in BFS order!',
    },
    hint: 'Consider expression evaluation, name lookup, code structure, and analysis order.',
  },
  {
    id: 11,
    title: 'Machine Learning Pipeline',
    description: 'Data structures in ML systems.',
    difficulty: 'hard',
    category: 'Machine Learning',
    structures: [
      DATA_STRUCTURES.array,
      DATA_STRUCTURES.hashTable,
      DATA_STRUCTURES.heap,
      DATA_STRUCTURES.graph,
      DATA_STRUCTURES.queue,
    ],
    applications: [
      {
        id: 'tensors',
        title: 'Neural Network Tensors',
        description: 'Multi-dimensional data for computations',
        icon: 'üß†',
        matchesStructure: 'array',
      },
      {
        id: 'embeddings',
        title: 'Word Embeddings Lookup',
        description: 'Converting words to vectors',
        icon: 'üìñ',
        matchesStructure: 'hashTable',
      },
      {
        id: 'knn',
        title: 'K-Nearest Neighbors',
        description: 'Finding K most similar items',
        icon: 'üéØ',
        matchesStructure: 'heap',
      },
      {
        id: 'computation',
        title: 'Computation Graph',
        description: 'Dependencies between operations',
        icon: 'üìä',
        matchesStructure: 'graph',
      },
      {
        id: 'batches',
        title: 'Training Batch Queue',
        description: 'Feeding data batches to model',
        icon: 'üì¶',
        matchesStructure: 'queue',
      },
    ],
    explanations: {
      array: 'Tensors are multi-dimensional arrays - the foundation of neural networks!',
      hashTable: 'Word embeddings map strings to vectors using hash tables!',
      heap: 'KNN uses heaps to efficiently track K smallest distances!',
      graph: 'Computation graphs track operation dependencies for backpropagation!',
      queue: 'Data loaders queue batches for training in order!',
    },
    hint: 'Think about numerical data, mappings, top-K, dependencies, and batching.',
  },
  {
    id: 12,
    title: 'Version Control Systems',
    description: 'How Git organizes your code history.',
    difficulty: 'hard',
    category: 'DevOps',
    structures: [
      DATA_STRUCTURES.graph,
      DATA_STRUCTURES.hashTable,
      DATA_STRUCTURES.trie,
      DATA_STRUCTURES.linkedList,
      DATA_STRUCTURES.stack,
    ],
    applications: [
      {
        id: 'commits',
        title: 'Commit History',
        description: 'DAG of commits with parent relationships',
        icon: 'üìú',
        matchesStructure: 'graph',
      },
      {
        id: 'objects',
        title: 'Object Store',
        description: 'Content-addressable storage by SHA hash',
        icon: 'üì¶',
        matchesStructure: 'hashTable',
      },
      {
        id: 'refs',
        title: 'Branch/Tag References',
        description: 'Named pointers with hierarchical names',
        icon: 'üè∑Ô∏è',
        matchesStructure: 'trie',
      },
      {
        id: 'reflog',
        title: 'Reference Log',
        description: 'Sequential history of ref updates',
        icon: 'üìù',
        matchesStructure: 'linkedList',
      },
      {
        id: 'stash',
        title: 'Git Stash',
        description: 'Temporarily saved changes',
        icon: 'üì•',
        matchesStructure: 'stack',
      },
    ],
    explanations: {
      graph: 'Git commits form a DAG - each commit points to parent(s)!',
      hashTable: 'Git objects are stored by SHA-1 hash for content addressing!',
      trie: 'Refs like refs/heads/main use trie-like hierarchical storage!',
      linkedList: 'Reflog is a sequential list of reference updates!',
      stack: 'Git stash is LIFO - stash pop gets the most recent stash!',
    },
    hint: 'Consider commit relationships, content hashing, naming, and temporary storage.',
  },
];

export default realWorldChallenges;
